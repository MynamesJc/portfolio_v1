<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image → Objet 3D (Extrusion) — Export .glb</title>
  <style>
    :root {
      --bg: #0f1720;
      --panel: #0b1220cc;
      --accent: #6ee7b7;
      --text: #e6eef6;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #0f1720 100%);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif;color:var(--text)}
    .wrap{display:grid;grid-template-columns:1fr 360px;gap:18px;height:100%;padding:18px;box-sizing:border-box}
    .viewer { border-radius:12px; overflow:hidden; box-shadow:0 12px 40px rgba(2,6,23,0.7); background:#020617; position:relative; }
    .panel {
      background:linear-gradient(180deg, rgba(8,12,20,0.6), rgba(6,8,14,0.5));
      border-radius:12px;
      padding:16px;
      color:var(--text);
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      height:100%;
      overflow:auto;
    }
    h1{font-size:16px;margin:0 0 12px 0}
    label{display:block;font-size:13px;margin-top:12px;color:#bcd3e8}
    input[type=file]{display:block;margin-top:8px}
    .row{display:flex;gap:8px;align-items:center;margin-top:10px}
    input[type=range]{width:100%}
    button{background:linear-gradient(90deg,var(--accent),#3dd3ff);border:0;padding:10px 12px;border-radius:8px;color:#021219;cursor:pointer;font-weight:600}
    .small{font-size:12px;color:#9fb3c8}
    footer.small{font-size:11px;color:#6e8aa6;margin-top:12px}
    .hint{margin-top:10px;padding:8px;background:#071730;border-radius:8px;color:#9fd6ff;font-size:13px}
    /* responsive */
    @media (max-width:920px){
      .wrap{grid-template-columns:1fr;grid-auto-rows:420px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="viewer" id="viewer"></div>

    <aside class="panel">
      <h1>Convertisseur Image → Objet 3D</h1>
      <div class="small">Téléverse une image (jpg/png). La luminosité définira la hauteur (heightmap).</div>

      <label>Image source (1 seule image)</label>
      <input id="fileInput" type="file" accept="image/*">

      <label>Résolution du maillage (segments) : <span id="segLabel">200</span></label>
      <input id="segments" type="range" min="10" max="600" step="1" value="200">

      <label>Force d'extrusion (displacement scale) : <span id="scaleLabel">0.6</span></label>
      <input id="scale" type="range" min="0" max="3" step="0.01" value="0.6">

      <label>Largeur / Hauteur de la plaque (en unités) :</label>
      <div class="row">
        <input id="width" type="number" value="2" step="0.1" style="width:48%;" />
        <input id="height" type="number" value="2" step="0.1" style="width:48%;" />
      </div>

      <div class="row" style="margin-top:14px;">
        <button id="buildBtn">Générer l'objet 3D</button>
        <button id="exportBtn" disabled>Exporter .glb</button>
      </div>

      <div class="hint">
        Astuce : pour des détails fins augmente "segments", mais cela augmente le nombre de triangles. Pour Blender, importe le .glb et fais des retouches.
      </div>

      <footer class="small">Mode d'emploi : téléverse → régler segments/scale → Générer → Exporter (.glb)</footer>
    </aside>
  </div>

  <!-- scripts three.js depuis CDN -->
  <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.152.0/examples/js/exporters/GLTFExporter.js"></script>

  <script>
    // Elements
    const viewer = document.getElementById('viewer');
    const fileInput = document.getElementById('fileInput');
    const segmentsEl = document.getElementById('segments');
    const segLabel = document.getElementById('segLabel');
    const scaleEl = document.getElementById('scale');
    const scaleLabel = document.getElementById('scaleLabel');
    const buildBtn = document.getElementById('buildBtn');
    const exportBtn = document.getElementById('exportBtn');
    const widthEl = document.getElementById('width');
    const heightEl = document.getElementById('height');

    segLabel.textContent = segmentsEl.value;
    scaleLabel.textContent = scaleEl.value;

    let uploadedImage = null;
    let scene, camera, renderer, controls;
    let mesh = null;
    let baseTexture = null;

    // init three
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x071024);
      camera = new THREE.PerspectiveCamera(45, viewer.clientWidth / viewer.clientHeight, 0.01, 100);
      camera.position.set(0, 1.2, 3);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(viewer.clientWidth, viewer.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      viewer.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0, 0);

      // lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(3, 6, 2);
      scene.add(dir);

      // ground subtle
      const grid = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.MeshStandardMaterial({ color: 0x061026, metalness:0.0, roughness:1 })
      );
      grid.rotation.x = -Math.PI/2;
      grid.position.y = -1.4;
      scene.add(grid);

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function onWindowResize() {
      camera.aspect = viewer.clientWidth / viewer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // read file
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          uploadedImage = img;
          alert('Image chargée : ' + f.name + '. Maintenant clique sur "Générer l\'objet 3D".');
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(f);
    });

    // UI updates
    segmentsEl.addEventListener('input', () => { segLabel.textContent = segmentsEl.value });
    scaleEl.addEventListener('input', () => { scaleLabel.textContent = scaleEl.value });

    // Build mesh from image (heightmap via luminance)
    buildBtn.addEventListener('click', async () => {
  if (!uploadedImage) { alert('Téléverse d\'abord une image.'); return; }

  const seg = parseInt(segmentsEl.value, 10);
  const displaceScale = parseFloat(scaleEl.value);
  const width = parseFloat(widthEl.value) || 2;
  const height = parseFloat(heightEl.value) || 2;

  if (mesh) {
    scene.remove(mesh);
    mesh.geometry.dispose();
    if (mesh.material.map) mesh.material.map.dispose();
    mesh.material.dispose();
    mesh = null;
  }

  // Utiliser ImageBitmap pour lire les pixels de manière sécurisée
  const bitmap = await createImageBitmap(uploadedImage);
  const cols = seg + 1;
  const rows = seg + 1;

  const offCanvas = new OffscreenCanvas(cols, rows);
  const ctx = offCanvas.getContext('2d');
  ctx.drawImage(bitmap, 0, 0, cols, rows);
  const imgData = ctx.getImageData(0, 0, cols, rows).data;

  // créer la géométrie
  const geometry = new THREE.PlaneGeometry(width, height, seg, seg);
  geometry.rotateX(-Math.PI/2);

  const pos = geometry.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const ix = i % (cols);
    const iy = Math.floor(i / (cols));
    const p = (iy * cols + ix) * 4;
    const r = imgData[p], g = imgData[p+1], b = imgData[p+2];
    const lum = (0.2126*r + 0.7152*g + 0.0722*b)/255;
    const z = (lum - 0.5) * displaceScale * Math.max(width, height);
    pos.setY(i, z);
  }
  pos.needsUpdate = true;
  geometry.computeVertexNormals();

  const texture = new THREE.Texture(bitmap);
  texture.needsUpdate = true;
  texture.encoding = THREE.sRGBEncoding;

  const mat = new THREE.MeshStandardMaterial({
    map: texture,
    metalness: 0.05,
    roughness: 0.7,
    side: THREE.DoubleSide
  });

  mesh = new THREE.Mesh(geometry, mat);
  scene.add(mesh);

  exportBtn.disabled = false;
  controls.target.set(0,0.05,0);
  camera.position.set(0, Math.max(width, height)*0.8, Math.max(width, height)*1.8);
  controls.update();

  alert('Objet 3D généré avec succès !');
});


    // Exporter GLB
    exportBtn.addEventListener('click', () => {
      if (!mesh) return;
      const exporter = new THREE.GLTFExporter();
      exporter.parse(mesh, (gltf) => {
        const blob = new Blob([gltf], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'image_extrude.glb';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, {binary: true, onlyVisible: true});
    });

    // init
    initThree();
  </script>
</body>
</html>
